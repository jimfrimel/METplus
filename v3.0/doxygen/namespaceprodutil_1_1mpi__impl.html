<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>METplus: produtil.mpi_impl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">METplus
   &#160;<span id="projectnumber">METplusV3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceprodutil.html">produtil</a></li><li class="navelem"><a class="el" href="namespaceprodutil_1_1mpi__impl.html">mpi_impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">produtil.mpi_impl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Converts a group of MPI ranks to a runnable command.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Converts a group of MPI ranks to a runnable command. </p>
<h1><a class="anchor" id="produtil_mpi_impl_overview"></a>
Produtil MPI Implementation</h1>
<p>This package and its submodules implement execution of externals MPI programs. This package is not intended to be used directly, instead one should use <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a>. This package appears to the outside to be a module that implements a common interface to various local MPI implementations. This is done by automatically detecting which MPI implementation is in use, and then importing the entire contents of the corresponding sub-module of <a class="el" href="namespaceprodutil_1_1mpi__impl.html" title="Converts a group of MPI ranks to a runnable command. ">produtil.mpi_impl</a>. See the submodules for details on each implementation:</p>
<ul>
<li>produtil.mpi_impl.mpiexec &mdash; MPICH or public MPVAPICH2</li>
<li>produtil.mpi_impl.impi &mdash; Intel MPI</li>
<li>produtil.mpi_impl.mpiexec_mpt &mdash; SGI MPT</li>
<li>produtil.mpi_impl.mpirun_lsf &mdash; LSF wrapped around IBMPE</li>
<li><a class="el" href="namespaceprodutil_1_1mpi__impl_1_1no__mpi.html" title="Stub funcitons to allow produtil.mpi_impl to run when MPI is unavailable. ">produtil.mpi_impl.no_mpi</a> &mdash; For a purely serial environment.</li>
</ul>
<h1><a class="anchor" id="produtil_mpi_impl_subroutines"></a>
Subroutines Imported from Implementation Modules</h1>
<p>The following subroutines are imported from one of those modules. They are added to the <a class="el" href="namespaceprodutil_1_1mpi__impl.html" title="Converts a group of MPI ranks to a runnable command. ">mpi_impl</a> package level to make the <a class="el" href="namespaceprodutil_1_1mpi__impl.html" title="Converts a group of MPI ranks to a runnable command. ">mpi_impl</a> look identical to the underlying implementation module:</p>
<ul>
<li>openmp(arg,threads) - given a Runner, set it up to use OpenMP If threads is provided, it is the number of threads to use. Otherwise, no thread count is specified and it is assumed that the underlying OpenMP implementation will use the correct number.</li>
<li>can_run_mpi() - does this computer support running MPI programs?</li>
<li>bigexe_prepend(arg,**kwargs) - Modifies an executable to run on a compute node instead of the batch node. This is intended for future support of the Cray architecture, where the batch script runs on a batch node, and must call "aprun" to execute a program on a remote compute node. This is the function that one would use to prepend "aprun" and its various arguments. This functionality is not presently tested.</li>
<li><p class="startli">mpirunner(arg,allranks=False,**kwargs) - Implementation of <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">produtil.run.mpirun()</a>. Given an object that is a subclass of <a class="el" href="classprodutil_1_1mpiprog_1_1MPIRanksBase.html" title="This is the abstract superclass of all classes that represent one or more MPI ranks, including MPI ranks that are actually serial programs. ">produtil.mpiprog.MPIRanksBase</a>, construct and return a <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">produtil.prog.Runner</a> that will execute that MPI command. The allranks=True option requests that the program use all available MPI ranks. An exception should be raised if the program also requests a specific number of ranks (other than 1).</p>
<p class="startli">There are two different types of MPI programs that mpirunner must handle. One is MPI execution of non-MPI programs, which the caller requests via <a class="el" href="namespaceprodutil_1_1run.html#ab25fe1dbe95b271368ca44e34dafa045" title="Generates an mpiprog.MPISerial object that represents an MPI rank that executes a serial (non-MPI) pr...">produtil.run.mpiserial</a>. Some MPI implementations support running non-MPI programs directly, while others don't. The external C program "mpiserial" provides an MPI wrapper program to work around that lack of support. It is a simple MPI program that directs each rank to execute a shell command. The other variety of program mpirunner must handle is, of course, MPI programs. These are differentiated via: (serial,parallel)=arg.check_serial() If serial is true, the program is serial, if parallel is true, the program is parallel. If both are true, MPIMixed should be raised.</p>
<p class="startli">The mpirunner must also handle the allranks=True vs. False cases. If allranks=True, the caller is requesting that the provided MPI program be run on all available ranks. If the MPI program also provides a rank specification (detected via arg.nranks()!=1) then the MPI_COMM_WORLD is overspecified and the mpirunner must raise MPIAllRanksError.</p>
</li>
</ul>
<p>These are the detection routines imported from each submodule, except for <a class="el" href="namespaceprodutil_1_1mpi__impl_1_1no__mpi.html" title="Stub funcitons to allow produtil.mpi_impl to run when MPI is unavailable. ">no_mpi</a>. The name of the routine is "detect()" in its module, and is renamed during import to the package-level namespace:</p>
<ul>
<li>impi_detect() &mdash; returns True if the Intel MPI should be used</li>
<li>mpiexec_detect() - returns True if the MPICH or MVAPICH2 MPI should be used</li>
<li>mpiexec_mpt_detect() - returns True if the SGI MPT should be used</li>
<li>mpirun_lsf_detect() - returns True if LSF IBMPE should be used</li>
</ul>
<h1><a class="anchor" id="Adding"></a>
New MPI Implementations</h1>
<p>To implement a new MPI implementation, one must create a new submodule of <a class="el" href="namespaceprodutil_1_1mpi__impl.html" title="Converts a group of MPI ranks to a runnable command. ">mpi_impl</a>. It is best to examine the existing modules and mimic them when doing this. Most architectures are similar to either the mpirun_lsf (which uses command files) or mpiexec (which provides arguments to mpiexec on the command line). In addition, the external program "mpiserial" provides a means by which to execute a list of serial programs via an MPI invocation for MPI implementations that do not natively support that (such as the problematic SGI MPT). Furthermore, some MPI implementations may have bugs or limitations that one must work around via setting environment variables (such as SGI MPT with its numerous hard-coded limits). The mpirunner and openmp functions should work around those problems.</p>
<p>Note that there are two utilities designed to simplify the implementation of a new MPI module:</p>
<ul>
<li><a class="el" href="classprodutil_1_1mpiprog_1_1MPIRanksBase.html#a48f04bba48bd74cc9d12b46da3227aaa" title="This is the underlying implementation of most of the mpi_impl modules, and hence make_runner as well...">produtil.mpiprog.MPIRanksBase.to_arglist()</a> &ndash; walks the tree of objects automatically generating an mpi invocation command (mpiexec, mpirun, etc.) with arguments, based on a provided set of rules. This is how the three existing modules make their MPI commands. It is quite simple to use, and handles the hard work of walking the object tree for you.</li>
<li><a class="el" href="classprodutil_1_1mpi__impl_1_1mpi__impl__base_1_1CMDFGen.html" title="Generates files with one line per MPI rank, telling what program to run on each rank. ">produtil.mpi_impl.mpi_impl_base.CMDFGen</a> - provides a way of easily writing a command file based on <a class="el" href="classprodutil_1_1mpiprog_1_1MPISerial.html" title="Represents a single rank of an MPI program that is actually running a serial program. ">produtil.mpiprog.MPISerial</a> objects. This is for MPI implementations such as IBMPE that require a file listing the commands to run on each MPI rank. It is also needed when using mpiserial to execute non-MPI programs under MPI</li>
</ul>
<p>Once you have a new MPI implementation module, you must edit <a class="el" href="mpi__impl_2____init_____8py_source.html">produtil/mpi_impl/__init__.py</a> to detect your MPI implementation and correctly import the module. The <a class="el" href="mpi__impl_2____init_____8py_source.html">produtil/mpi_impl/__init__.py</a> must import that module's detect() function, and detect whether the MPI implementation should be used. If it should be, then <b>init</b>.py must import the relevant symbols from your module into the package-level namespace. There are instructions in the code in <b>init</b>.py on how to modify it to achieve these steps. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceprodutil_1_1mpi__impl_1_1mpi__impl__base"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl_1_1mpi__impl__base.html">mpi_impl_base</a></td></tr>
<tr class="memdesc:namespaceprodutil_1_1mpi__impl_1_1mpi__impl__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities like <a class="el" href="classprodutil_1_1mpi__impl_1_1mpi__impl__base_1_1CMDFGen.html" title="Generates files with one line per MPI rank, telling what program to run on each rank. ">CMDFGen</a> to simplify adding new MPI implementations to the <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a> suite of modules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceprodutil_1_1mpi__impl_1_1no__mpi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl_1_1no__mpi.html">no_mpi</a></td></tr>
<tr class="memdesc:namespaceprodutil_1_1mpi__impl_1_1no__mpi"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stub funcitons to allow <a class="el" href="namespaceprodutil_1_1mpi__impl.html" title="Converts a group of MPI ranks to a runnable command. ">produtil.mpi_impl</a> to run when MPI is unavailable. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceprodutil_1_1mpi__impl_1_1srun"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl_1_1srun.html">srun</a></td></tr>
<tr class="memdesc:namespaceprodutil_1_1mpi__impl_1_1srun"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds SLURM srun support to <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac9e81578eb65893b55eff6fd2cedaa8e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl.html#ac9e81578eb65893b55eff6fd2cedaa8e">add_implementation</a> (clazz)</td></tr>
<tr class="memdesc:ac9e81578eb65893b55eff6fd2cedaa8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an MPI implementation class to the list of implementations to detect.  <a href="#ac9e81578eb65893b55eff6fd2cedaa8e">More...</a><br /></td></tr>
<tr class="separator:ac9e81578eb65893b55eff6fd2cedaa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bb53d25c4c86f018a514897d34dff5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a15bb53d25c4c86f018a514897d34dff5">register_implementations</a> (logger=None)</td></tr>
<tr class="memdesc:a15bb53d25c4c86f018a514897d34dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all known MPI implementations to the list for get_mpi detection.  <a href="#a15bb53d25c4c86f018a514897d34dff5">More...</a><br /></td></tr>
<tr class="separator:a15bb53d25c4c86f018a514897d34dff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6e34e8dc0bb2321408fad882bac673"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a8b6e34e8dc0bb2321408fad882bac673">get_mpi</a> (mpi_name=<a class="el" href="namespaceprodutil_1_1mpi__impl.html#a4a1c8d01aecee73c028159c41b193c2d">NO_NAME</a>, force=False, logger=None, kwargs)</td></tr>
<tr class="memdesc:a8b6e34e8dc0bb2321408fad882bac673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a specified MPI implementation, or automatically detects the currently available one.  <a href="#a8b6e34e8dc0bb2321408fad882bac673">More...</a><br /></td></tr>
<tr class="separator:a8b6e34e8dc0bb2321408fad882bac673"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a25aab6b584e9dc026b45098e8e46147f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a25aab6b584e9dc026b45098e8e46147f">detectors</a> = dict()</td></tr>
<tr class="memdesc:a25aab6b584e9dc026b45098e8e46147f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from MPI implementation name to its detection function.  <a href="#a25aab6b584e9dc026b45098e8e46147f">More...</a><br /></td></tr>
<tr class="separator:a25aab6b584e9dc026b45098e8e46147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235d476491f249c9046d2ec7f01f4007"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a235d476491f249c9046d2ec7f01f4007">synonyms</a> = dict()</td></tr>
<tr class="memdesc:a235d476491f249c9046d2ec7f01f4007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows multiple names for the same MPI implementation.  <a href="#a235d476491f249c9046d2ec7f01f4007">More...</a><br /></td></tr>
<tr class="separator:a235d476491f249c9046d2ec7f01f4007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24544743d1525f30c9a1f6124d21786b"><td class="memItemLeft" align="right" valign="top"><a id="a24544743d1525f30c9a1f6124d21786b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>detection_order</b> = list()</td></tr>
<tr class="separator:a24544743d1525f30c9a1f6124d21786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbab0f624bd79776db14d4011dd1c32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl.html#acfbab0f624bd79776db14d4011dd1c32">no_implementation</a> = None</td></tr>
<tr class="memdesc:acfbab0f624bd79776db14d4011dd1c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special implementation object that is used when no implementation is avalable.  <a href="#acfbab0f624bd79776db14d4011dd1c32">More...</a><br /></td></tr>
<tr class="separator:acfbab0f624bd79776db14d4011dd1c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1c8d01aecee73c028159c41b193c2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a4a1c8d01aecee73c028159c41b193c2d">NO_NAME</a> = object()</td></tr>
<tr class="memdesc:a4a1c8d01aecee73c028159c41b193c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value for the <a class="el" href="namespaceprodutil_1_1mpi__impl.html#a8b6e34e8dc0bb2321408fad882bac673" title="Selects a specified MPI implementation, or automatically detects the currently available one...">get_mpi()</a> mpi_name to indicate the mpi_name argument was not set.  <a href="#a4a1c8d01aecee73c028159c41b193c2d">More...</a><br /></td></tr>
<tr class="separator:a4a1c8d01aecee73c028159c41b193c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac9e81578eb65893b55eff6fd2cedaa8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e81578eb65893b55eff6fd2cedaa8e">&#9670;&nbsp;</a></span>add_implementation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.mpi_impl.add_implementation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clazz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an MPI implementation class to the list of implementations to detect. </p>
<p>Adds this implementation to the module-level detectors and detection_order. The class must have the following static methods:</p>
<ul>
<li>name - the name of the class</li>
<li>detect - a function that detects the implementation</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a25aab6b584e9dc026b45098e8e46147f" title="Mapping from MPI implementation name to its detection function. ">produtil.mpi_impl.detectors</a> for more information</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class</td><td>a class that implements the name and detect functions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpi__impl_2____init_____8py_source.html#l00168">168</a> of file <a class="el" href="mpi__impl_2____init_____8py_source.html">__init__.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="mpi__impl_2____init_____8py_source.html#l00193">produtil.mpi_impl.register_implementations()</a>.</p>

</div>
</div>
<a id="a8b6e34e8dc0bb2321408fad882bac673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6e34e8dc0bb2321408fad882bac673">&#9670;&nbsp;</a></span>get_mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.mpi_impl.get_mpi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mpi_name</em> = <code><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a4a1c8d01aecee73c028159c41b193c2d">NO_NAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects a specified MPI implementation, or automatically detects the currently available one. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an internal implementation function that should never be called directly. Use produtil.run.get_mpi() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_name</td><td>Optional: the name of the desired MPI implementation, or None to request running without MPI.</td></tr>
    <tr><td class="paramname">force</td><td>if True, and mpi_name is given, the MPI implementation will be used even if it is not available on the current machine. Note that if the name is not recognized, this function will still raise an exception even if force=True. Default is False.</td></tr>
    <tr><td class="paramname">logger</td><td>a logging.Logger for messages.</td></tr>
    <tr><td class="paramname">kwargs</td><td>Optional: additional keyword arguments to pass to the MPI implementation detection functions.</td></tr>
  </table>
  </dd>
</dl>
<p>NotImplementedError if the MPI implementation is unknown, or if the implementation is unavailble on this machine, and force=False </p>

<p class="definition">Definition at line <a class="el" href="mpi__impl_2____init_____8py_source.html#l00304">304</a> of file <a class="el" href="mpi__impl_2____init_____8py_source.html">__init__.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="run_8py_source.html#l00221">produtil.run.detect_mpi()</a>, and <a class="el" href="run_8py_source.html#l00183">produtil.run.make_mpi()</a>.</p>

</div>
</div>
<a id="a15bb53d25c4c86f018a514897d34dff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bb53d25c4c86f018a514897d34dff5">&#9670;&nbsp;</a></span>register_implementations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.mpi_impl.register_implementations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all known MPI implementations to the list for get_mpi detection. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is part of the internal implementation of <a class="el" href="namespaceprodutil_1_1mpi__impl.html#a8b6e34e8dc0bb2321408fad882bac673" title="Selects a specified MPI implementation, or automatically detects the currently available one...">get_mpi()</a> and should never be called directly.</dd></dl>
<p>Loops over all MPI implementation modules inside <a class="el" href="namespaceprodutil_1_1mpi__impl.html" title="Converts a group of MPI ranks to a runnable command. ">produtil.mpi_impl</a> and adds each one to the list of MPI implementations. Also adds the special "no implementation" fallback from <a class="el" href="namespaceprodutil_1_1mpi__impl_1_1no__mpi.html" title="Stub funcitons to allow produtil.mpi_impl to run when MPI is unavailable. ">produtil.mpi_impl.no_mpi</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprodutil_1_1mpi__impl.html#acfbab0f624bd79776db14d4011dd1c32" title="The special implementation object that is used when no implementation is avalable. ">produtil.mpi_impl.no_implementation</a> </dd>
<dd>
<a class="el" href="namespaceprodutil_1_1mpi__impl.html#a8b6e34e8dc0bb2321408fad882bac673" title="Selects a specified MPI implementation, or automatically detects the currently available one...">produtil.mpi_impl.get_mpi</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi__impl_2____init_____8py_source.html#l00193">193</a> of file <a class="el" href="mpi__impl_2____init_____8py_source.html">__init__.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="mpi__impl_2____init_____8py_source.html#l00304">produtil.mpi_impl.get_mpi()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a25aab6b584e9dc026b45098e8e46147f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25aab6b584e9dc026b45098e8e46147f">&#9670;&nbsp;</a></span>detectors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">produtil.mpi_impl.detectors = dict()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from MPI implementation name to its detection function. </p>
<p>A mapping from MPI implementation name to a class static method that detects that implementation. When detection succeeds, the function should return an instance of the class. Otherwise, it should return None. The function must have at least these two optional arguments and must be able to discard any other optional arguments:</p>
<ul>
<li>logger &mdash; a logging.Logger object for log messages</li>
<li>force &mdash; if True, the detector must succeed and return an Implementation that has suitable defaults. This is used to generate mpi execution commands outside the job that will run them. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="mpi__impl_2____init_____8py_source.html#l00149">149</a> of file <a class="el" href="mpi__impl_2____init_____8py_source.html">__init__.py</a>.</p>

</div>
</div>
<a id="acfbab0f624bd79776db14d4011dd1c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbab0f624bd79776db14d4011dd1c32">&#9670;&nbsp;</a></span>no_implementation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">produtil.mpi_impl.no_implementation = None</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The special implementation object that is used when no implementation is avalable. </p>

<p class="definition">Definition at line <a class="el" href="mpi__impl_2____init_____8py_source.html#l00166">166</a> of file <a class="el" href="mpi__impl_2____init_____8py_source.html">__init__.py</a>.</p>

</div>
</div>
<a id="a4a1c8d01aecee73c028159c41b193c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1c8d01aecee73c028159c41b193c2d">&#9670;&nbsp;</a></span>NO_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">produtil.mpi_impl.NO_NAME = object()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special value for the <a class="el" href="namespaceprodutil_1_1mpi__impl.html#a8b6e34e8dc0bb2321408fad882bac673" title="Selects a specified MPI implementation, or automatically detects the currently available one...">get_mpi()</a> mpi_name to indicate the mpi_name argument was not set. </p>
<p>Do not modify. </p>

<p class="definition">Definition at line <a class="el" href="mpi__impl_2____init_____8py_source.html#l00191">191</a> of file <a class="el" href="mpi__impl_2____init_____8py_source.html">__init__.py</a>.</p>

</div>
</div>
<a id="a235d476491f249c9046d2ec7f01f4007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235d476491f249c9046d2ec7f01f4007">&#9670;&nbsp;</a></span>synonyms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">produtil.mpi_impl.synonyms = dict()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows multiple names for the same MPI implementation. </p>
<p>For example, "moab_cray" is an alias for "lsf_cray_intel" </p>

<p class="definition">Definition at line <a class="el" href="mpi__impl_2____init_____8py_source.html#l00154">154</a> of file <a class="el" href="mpi__impl_2____init_____8py_source.html">__init__.py</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
