<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>METplus: produtil.run Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">METplus
   &#160;<span id="projectnumber">METplusV3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceprodutil.html">produtil</a></li><li class="navelem"><a class="el" href="namespaceprodutil_1_1run.html">run</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">produtil.run Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A shell-like syntax for running serial, MPI and OpenMP programs.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A shell-like syntax for running serial, MPI and OpenMP programs. </p>
<p>This module implements a shell-like syntax for launching MPI and non-MPI programs from Python. It recognizes three types of executables: mpi, "small serial" (safe for running on a batch node) and "big serial" (which should be run via aprun if applicable). There is no difference between "small serial" and "big serial" programs except on certain architectures (like Cray) where the job script runs on a heavily-loaded batch node and has compute nodes assigned for running other programs.</p>
<h1><a class="anchor" id="progtype"></a>
Program Types</h1>
<p>There are three types of programs: mpi, serial and "big non-MPI." A "big" executable is one that is either OpenMP, or is a serial program that cannot safely be run on heavily loaded batch nodes. On Cray architecture machines, the job script runs on a heavily-populated "batch" node, with some compute nodes assigned for "large" programs. In such environments, the "big" executables are run on compute nodes and the small ones on the batch node.</p>
<ul>
<li>mpi('exename') = an executable "exename" that calls MPI_Init and MPI_Finalize exactly once each, in that order.</li>
<li>exe('exename') = a small non-MPI program safe to run on a batch node</li>
<li>bigexe('exename') = a big non-MPI program that must be run on a compute node it may or may not use other forms of parallelism</li>
</ul>
<p>You can also make reusable aliases to avoid having to call those functions over and over (more on that later). Examples:</p>
<ul>
<li>Python: wrf=mpi('./wrf.exe')</li>
<li>Python: lsl=alias(exe('/bin/ls')['-l'].env(LANG='C',LS_COLORS='never'))</li>
</ul>
<p>Those can then be reused later on as if the code is pasted in, similar to a shell alias.</p>
<h1><a class="anchor" id="serexs"></a>
Serial Execution Syntax</h1>
<p>Select your serial programs by exe('name') for small serial programs and bigexe('name') for big serial programs. The return value of those functions can then be used with a shell-like syntax to specify redirection and piping. Example:</p>
<ul>
<li>shell version: ls -l / | wc -l</li>
<li>Python version: run(exe('ls')['-l','/'] | exe('wc')['-l'])</li>
</ul>
<p>Redirection syntax similar to the shell (&lt; &gt; and &lt;&lt; operators): </p><div class="fragment"><div class="line">run( ( exe(<span class="stringliteral">&#39;myprogram&#39;</span>)[<span class="stringliteral">&#39;arg1&#39;</span>,<span class="stringliteral">&#39;arg2&#39;</span>,<span class="stringliteral">&#39;...&#39;</span>] &lt; <span class="stringliteral">&#39;infile&#39;</span> ) &gt; <span class="stringliteral">&#39;outfile&#39;</span>)</div></div><!-- fragment --><p>Note the extra set of parentheses: you cannot do "exe('prog') &lt; infile </p><blockquote class="doxtable">
<p>outfile" because of the order of precedence of Python operators </p>
</blockquote>
<p>Append also works: </p><div class="fragment"><div class="line">run(exe(<span class="stringliteral">&#39;myprogram&#39;</span>)[<span class="stringliteral">&#39;arg1&#39;</span>,<span class="stringliteral">&#39;arg2&#39;</span>,<span class="stringliteral">&#39;...&#39;</span>] &gt;&gt; <span class="stringliteral">&#39;appendfile&#39;</span>)</div></div><!-- fragment --><p>You can also send strings as input with &lt;&lt; </p><div class="fragment"><div class="line">run(exe(<span class="stringliteral">&#39;myprogram&#39;</span>)[<span class="stringliteral">&#39;arg1&#39;</span>,<span class="stringliteral">&#39;arg2&#39;</span>,<span class="stringliteral">&#39;...&#39;</span>] &lt;&lt; <span class="stringliteral">&#39;some input string&#39;</span>)</div></div><!-- fragment --><p>One difference from shells is that &lt; and &lt;&lt; always modify the beginning of the pipeline:</p>
<ul>
<li>shell: cat &lt; infile | wc -l</li>
<li>Python #1: ( exe('cat') &lt; 'infile' ) | exe('wc')['-l']</li>
<li>Python #2: exe('cat') | ( exe('wc')['-l'] &lt; 'infile' )</li>
</ul>
<p>Note that the last second one, equivalent to <code>cat|wc -l&lt;infile</code>, would NOT work in a shell since you would be giving wc -l two inputs.</p>
<h1><a class="anchor" id="parexs"></a>
Parallel Execution Syntax</h1>
<p>Use mpi('exename') to select your executable, use [] to set arguments, use multiplication to set the number of ranks and use addition to combine different executables together into a multiple program multiple data (MPMD) MPI program.</p>
<p>Run ten copies of ls -l: </p><div class="fragment"><div class="line">run(mpirun(mpiserial((<span class="stringliteral">&#39;ls&#39;</span>)[<span class="stringliteral">&#39;-l&#39;</span>])*10))</div></div><!-- fragment --><p>Run HyCOM coupled HWRF: one wm3c.exe, 30 hycom.exe and 204 wrf.exe: </p><div class="fragment"><div class="line">run(mpirun(mpi(<span class="stringliteral">&#39;wm3c.exe&#39;</span>) + mpi(<span class="stringliteral">&#39;hycom.exe&#39;</span>)*30 + mpi(<span class="stringliteral">&#39;wrf.exe&#39;</span>)*204))</div></div><!-- fragment --><p>You can set environment variables, pipe MPI output and handle redirection using the <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">mpirun()</a> function, which converts MPI programs into an <a class="el" href="namespaceprodutil_1_1run.html#a464fb6f6962509db1435c250b2b88fd6" title="Alias for exe() for backward compatibility. ">bigexe()</a>-style object (Runner):</p>
<p>Shell version: </p><div class="fragment"><div class="line">result=$( mpirun -n 30 hostname | sort -u | wc -l )</div></div><!-- fragment --><p>Python version: </p><div class="fragment"><div class="line">result=runstr( mpirun(mpi(<span class="stringliteral">&#39;hostname&#39;</span>)*30) | exe[<span class="stringliteral">&#39;sort&#39;</span>][<span class="stringliteral">&#39;-u&#39;</span>] | exe[<span class="stringliteral">&#39;wc&#39;</span>][<span class="stringliteral">&#39;-l&#39;</span>] )</div></div><!-- fragment --><h1><a class="anchor" id="aliases"></a>
Aliases</h1>
<p>If you find yourself frequently needing the same command, or you need to store a command for multiple uses, then then you should define an alias. Let's say you want "long output" format Japanese language "ls" output:</p>
<div class="fragment"><div class="line">exe(<span class="stringliteral">&#39;ls&#39;</span>)[<span class="stringliteral">&#39;-l&#39;</span>,<span class="stringliteral">&#39;/path/to/dir&#39;</span>].env(LANG=<span class="stringliteral">&#39;JP&#39;</span>)</div></div><!-- fragment --><p>but you find yourself running that on many different directories. Then you may want to make an alias:</p>
<div class="fragment"><div class="line">jplsl=alias(exe(<span class="stringliteral">&#39;ls&#39;</span>)[<span class="stringliteral">&#39;-l&#39;</span>].env(LANG=<span class="stringliteral">&#39;JP&#39;</span>))</div></div><!-- fragment --><p>The return value jplsl can be treated as an <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>-like return value since it was from <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a> originally, but any new arguments will be appended to the original set:</p>
<div class="fragment"><div class="line">run(jplsl[<span class="stringliteral">&#39;/path/to/dir&#39;</span>])</div></div><!-- fragment --><p>Note that if we did this: </p><div class="fragment"><div class="line">badlsl=exe(<span class="stringliteral">&#39;ls&#39;</span>)[<span class="stringliteral">&#39;-l&#39;</span>].env(LANG=<span class="stringliteral">&#39;JP&#39;</span>)  <span class="comment"># Bad! No alias!</span></div><div class="line">run(badlsl[<span class="stringliteral">&#39;/&#39;</span>])  <span class="comment"># will list /</span></div><div class="line">run(badlsl[<span class="stringliteral">&#39;/home&#39;</span>])  <span class="comment"># will list / and /home</span></div><div class="line">run(badlsl[<span class="stringliteral">&#39;/usr/bin&#39;</span>]) <span class="comment"># will list / /home and /usr/bin</span></div><div class="line"></div><div class="line">goodlsl=alias(exe(<span class="stringliteral">&#39;ls&#39;</span>)[<span class="stringliteral">&#39;-l&#39;</span>].env(LANG=<span class="stringliteral">&#39;JP&#39;</span>)</div><div class="line">run(goodlsl[<span class="stringliteral">&#39;/&#39;</span>])  <span class="comment"># will list /</span></div><div class="line">run(goodlsl[<span class="stringliteral">&#39;/home&#39;</span>])  <span class="comment"># will list /home</span></div><div class="line">run(goodlsl[<span class="stringliteral">&#39;/usr/bin&#39;</span>]) <span class="comment"># will list /usr/bin</span></div></div><!-- fragment --><p>Then the run(badlsl['/home']) would list /home AND / which is NOT what we want. Why does it do that? It is because badlsl is not an alias &mdash; it is a regular output from <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>, so every time we call its [] operator, we add an argument to the original command. When we call <a class="el" href="namespaceprodutil_1_1run.html#a3dcd3d593127d9658c7d7dfe877ed44b" title="Attempts to generate an unmodifiable &quot;copy on write&quot; version of the argument. ">alias()</a> it returns a copy-on-write version (goodlsl), where every call to [] creates a new object.</p>
<p>Note that <a class="el" href="namespaceprodutil_1_1run.html#a3dcd3d593127d9658c7d7dfe877ed44b" title="Attempts to generate an unmodifiable &quot;copy on write&quot; version of the argument. ">alias()</a> also works with pipelines, but most operations will only modify the last the command in the pipeline (or the first, for operations that change stdin). </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a01495efdbad7b416f438ff6526ebedfb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a01495efdbad7b416f438ff6526ebedfb">make_mpi</a> (mpi_name=<a class="el" href="namespaceprodutil_1_1mpi__impl.html#a4a1c8d01aecee73c028159c41b193c2d">produtil.mpi_impl.NO_NAME</a>, kwargs)</td></tr>
<tr class="memdesc:a01495efdbad7b416f438ff6526ebedfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an MPI implementation object for the specified MPI implementation.  <a href="#a01495efdbad7b416f438ff6526ebedfb">More...</a><br /></td></tr>
<tr class="separator:a01495efdbad7b416f438ff6526ebedfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d9ae2ac8b1dde45318d95350b05afb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a63d9ae2ac8b1dde45318d95350b05afb">detect_mpi</a> ()</td></tr>
<tr class="memdesc:a63d9ae2ac8b1dde45318d95350b05afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by functions inside <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a> to automatically detect the available MPI implementation.  <a href="#a63d9ae2ac8b1dde45318d95350b05afb">More...</a><br /></td></tr>
<tr class="separator:a63d9ae2ac8b1dde45318d95350b05afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd3d593127d9658c7d7dfe877ed44b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a3dcd3d593127d9658c7d7dfe877ed44b">alias</a> (arg)</td></tr>
<tr class="memdesc:a3dcd3d593127d9658c7d7dfe877ed44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to generate an unmodifiable "copy on write" version of the argument.  <a href="#a3dcd3d593127d9658c7d7dfe877ed44b">More...</a><br /></td></tr>
<tr class="separator:a3dcd3d593127d9658c7d7dfe877ed44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41009f7327549010741ebb29aa1ba6f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a41009f7327549010741ebb29aa1ba6f7">batchexe</a> (name, kwargs)</td></tr>
<tr class="memdesc:a41009f7327549010741ebb29aa1ba6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">prog.ImmutableRunner</a> object that represents a small serial program that can be safely run on a busy batch node.  <a href="#a41009f7327549010741ebb29aa1ba6f7">More...</a><br /></td></tr>
<tr class="separator:a41009f7327549010741ebb29aa1ba6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac766be0e96246e1b74c556f24aa69d7f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f">exe</a> (name, mpiimpl=None, kwargs)</td></tr>
<tr class="memdesc:ac766be0e96246e1b74c556f24aa69d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">prog.ImmutableRunner</a> object that represents a large serial program that must be run on a compute node.  <a href="#ac766be0e96246e1b74c556f24aa69d7f">More...</a><br /></td></tr>
<tr class="separator:ac766be0e96246e1b74c556f24aa69d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464fb6f6962509db1435c250b2b88fd6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a464fb6f6962509db1435c250b2b88fd6">bigexe</a> (name, kwargs)</td></tr>
<tr class="memdesc:a464fb6f6962509db1435c250b2b88fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a> for backward compatibility.  <a href="#a464fb6f6962509db1435c250b2b88fd6">More...</a><br /></td></tr>
<tr class="separator:a464fb6f6962509db1435c250b2b88fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39d0f0caa4e35b673279f1e8d5166be"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be">mpirun</a> (arg, mpiimpl=None, kwargs)</td></tr>
<tr class="memdesc:ab39d0f0caa4e35b673279f1e8d5166be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an MPI program specification into a runnable shell program suitable for <a class="el" href="namespaceprodutil_1_1run.html#a051fdcf06abe4cd46bd9b528ed78ff55" title="Executes the specified program and attempts to return its exit status. ">run()</a>, <a class="el" href="namespaceprodutil_1_1run.html#adb62b5e57720ae6f0a012ef77a654be5" title="Executes the specified program or pipeline, capturing its stdout and returning that as a string...">runstr()</a> or <a class="el" href="namespaceprodutil_1_1run.html#a4f375f2804bfd933db8c52d3231642e4" title="This is a simple wrapper round run that raises ExitStatusException if the program exit status is non-...">checkrun()</a>.  <a href="#ab39d0f0caa4e35b673279f1e8d5166be">More...</a><br /></td></tr>
<tr class="separator:ab39d0f0caa4e35b673279f1e8d5166be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3201de880ff4d8d45c2671bfb0c2d40"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#ab3201de880ff4d8d45c2671bfb0c2d40">make_pipeline</a> (arg, capture, mpiimpl=None, kwargs)</td></tr>
<tr class="memdesc:ab3201de880ff4d8d45c2671bfb0c2d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This internal implementation function generates a prog.PopenCommand object for the specified input, which may be a <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">prog.Runner</a> or <a class="el" href="classprodutil_1_1mpiprog_1_1MPIRanksBase.html" title="This is the abstract superclass of all classes that represent one or more MPI ranks, including MPI ranks that are actually serial programs. ">mpiprog.MPIRanksBase</a>.  <a href="#ab3201de880ff4d8d45c2671bfb0c2d40">More...</a><br /></td></tr>
<tr class="separator:ab3201de880ff4d8d45c2671bfb0c2d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496dc065fbd02b7c1b2ff52d76934969"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a496dc065fbd02b7c1b2ff52d76934969">runbg</a> (arg, capture=False, kwargs)</td></tr>
<tr class="memdesc:a496dc065fbd02b7c1b2ff52d76934969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented: background execution.  <a href="#a496dc065fbd02b7c1b2ff52d76934969">More...</a><br /></td></tr>
<tr class="separator:a496dc065fbd02b7c1b2ff52d76934969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87458edd4ccb66771bf9d503096a28f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a87458edd4ccb66771bf9d503096a28f9">waitprocs</a> (procs, logger=None, timeout=None, usleep=1000)</td></tr>
<tr class="memdesc:a87458edd4ccb66771bf9d503096a28f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented: background process monitoring.  <a href="#a87458edd4ccb66771bf9d503096a28f9">More...</a><br /></td></tr>
<tr class="separator:a87458edd4ccb66771bf9d503096a28f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af272da55d241830e5451e122da395b8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#af272da55d241830e5451e122da395b8f">runsync</a> (logger=None, mpiimpl=None)</td></tr>
<tr class="memdesc:af272da55d241830e5451e122da395b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the "sync" command as an <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>.  <a href="#af272da55d241830e5451e122da395b8f">More...</a><br /></td></tr>
<tr class="separator:af272da55d241830e5451e122da395b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051fdcf06abe4cd46bd9b528ed78ff55"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a051fdcf06abe4cd46bd9b528ed78ff55">run</a> (arg, logger=None, sleeptime=None, kwargs)</td></tr>
<tr class="memdesc:a051fdcf06abe4cd46bd9b528ed78ff55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the specified program and attempts to return its exit status.  <a href="#a051fdcf06abe4cd46bd9b528ed78ff55">More...</a><br /></td></tr>
<tr class="separator:a051fdcf06abe4cd46bd9b528ed78ff55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f375f2804bfd933db8c52d3231642e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a4f375f2804bfd933db8c52d3231642e4">checkrun</a> (arg, logger=None, kwargs)</td></tr>
<tr class="memdesc:a4f375f2804bfd933db8c52d3231642e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple wrapper round run that raises ExitStatusException if the program exit status is non-zero.  <a href="#a4f375f2804bfd933db8c52d3231642e4">More...</a><br /></td></tr>
<tr class="separator:a4f375f2804bfd933db8c52d3231642e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d7fdc729ba882177296edcd1d3f10f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a51d7fdc729ba882177296edcd1d3f10f">openmp</a> (arg, threads=None, mpiimpl=None)</td></tr>
<tr class="memdesc:a51d7fdc729ba882177296edcd1d3f10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of OpenMP threads for the specified program.  <a href="#a51d7fdc729ba882177296edcd1d3f10f">More...</a><br /></td></tr>
<tr class="separator:a51d7fdc729ba882177296edcd1d3f10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb62b5e57720ae6f0a012ef77a654be5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#adb62b5e57720ae6f0a012ef77a654be5">runstr</a> (arg, logger=None, kwargs)</td></tr>
<tr class="memdesc:adb62b5e57720ae6f0a012ef77a654be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the specified program or pipeline, capturing its stdout and returning that as a string.  <a href="#adb62b5e57720ae6f0a012ef77a654be5">More...</a><br /></td></tr>
<tr class="separator:adb62b5e57720ae6f0a012ef77a654be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188c8f66465f19fc27e77085170a33e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#a188c8f66465f19fc27e77085170a33e4">mpi</a> (arg, kwargs)</td></tr>
<tr class="memdesc:a188c8f66465f19fc27e77085170a33e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an MPIRank object that represents the specified MPI executable.  <a href="#a188c8f66465f19fc27e77085170a33e4">More...</a><br /></td></tr>
<tr class="separator:a188c8f66465f19fc27e77085170a33e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25fe1dbe95b271368ca44e34dafa045"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#ab25fe1dbe95b271368ca44e34dafa045">mpiserial</a> (arg, kwargs)</td></tr>
<tr class="memdesc:ab25fe1dbe95b271368ca44e34dafa045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an <a class="el" href="classprodutil_1_1mpiprog_1_1MPISerial.html" title="Represents a single rank of an MPI program that is actually running a serial program. ">mpiprog.MPISerial</a> object that represents an MPI rank that executes a serial (non-MPI) program.  <a href="#ab25fe1dbe95b271368ca44e34dafa045">More...</a><br /></td></tr>
<tr class="separator:ab25fe1dbe95b271368ca44e34dafa045"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab01dbbada968bd0459c92aade00c672c"><td class="memItemLeft" align="right" valign="top"><a id="ab01dbbada968bd0459c92aade00c672c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprodutil_1_1run.html#ab01dbbada968bd0459c92aade00c672c">module_logger</a> = logging.getLogger('produtil.run')</td></tr>
<tr class="memdesc:ab01dbbada968bd0459c92aade00c672c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default logger used by some functions if no logger is given. <br /></td></tr>
<tr class="separator:ab01dbbada968bd0459c92aade00c672c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3dcd3d593127d9658c7d7dfe877ed44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd3d593127d9658c7d7dfe877ed44b">&#9670;&nbsp;</a></span>alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.alias </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to generate an unmodifiable "copy on write" version of the argument. </p>
<p>The returned copy will generate a modifiable duplicate of itself if you attempt to change it. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">produtil.prog.ImmutableRunner</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>a <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">produtil.prog.Runner</a> or <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">produtil.prog.ImmutableRunner</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00267">267</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
<a id="a41009f7327549010741ebb29aa1ba6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41009f7327549010741ebb29aa1ba6f7">&#9670;&nbsp;</a></span>batchexe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.batchexe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">prog.ImmutableRunner</a> object that represents a small serial program that can be safely run on a busy batch node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the executable name or path </td></tr>
    <tr><td class="paramname">kwargs</td><td>passed to <a class="el" href="classprodutil_1_1prog_1_1Runner.html#ade5a2e90df814ee4b57b90d3363f538d" title="Creates a new Runner. ">produtil.prog.Runner.__init__</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">produtil.prog.ImmutableRunner</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00281">281</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="parsetree_8py_source.html#l02132">produtil.testing.parsetree.EmbedBash.run()</a>.</p>

</div>
</div>
<a id="a464fb6f6962509db1435c250b2b88fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464fb6f6962509db1435c250b2b88fd6">&#9670;&nbsp;</a></span>bigexe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.bigexe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a> for backward compatibility. </p>
<p>Use <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00303">303</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
<a id="a4f375f2804bfd933db8c52d3231642e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f375f2804bfd933db8c52d3231642e4">&#9670;&nbsp;</a></span>checkrun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.checkrun </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a simple wrapper round run that raises ExitStatusException if the program exit status is non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">produtil.prog.Runner</a> to execute (output of <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>, <a class="el" href="namespaceprodutil_1_1run.html#a464fb6f6962509db1435c250b2b88fd6" title="Alias for exe() for backward compatibility. ">bigexe()</a> or <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">mpirun()</a> </td></tr>
    <tr><td class="paramname">logger</td><td>a logging.Logger to log messages </td></tr>
    <tr><td class="paramname">kwargs</td><td>The optional run=[] argument can provide a different list of acceptable exit statuses. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00456">456</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
<a id="a63d9ae2ac8b1dde45318d95350b05afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d9ae2ac8b1dde45318d95350b05afb">&#9670;&nbsp;</a></span>detect_mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.detect_mpi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by functions inside <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a> to automatically detect the available MPI implementation. </p>
<p>Detects the available MPI implementation - but that isn't as simple as it sounds. The detection logic requires calling <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a>. Hence, <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a> must be usable during the call to <a class="el" href="namespaceprodutil_1_1run.html#a63d9ae2ac8b1dde45318d95350b05afb" title="Called by functions inside produtil.run to automatically detect the available MPI implementation...">detect_mpi()</a>. The way this is handled is in three steps:</p>
<ol type="1">
<li>Set the MPI implementation to "no MPI." This will allow all serial (non-OpenMP, non-MPI) calls to succeed.</li>
<li>Run the MPI implementation detection functions. These will be able to use <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a> to execute serial programs to detect the MPI implementation.</li>
<li>If an MPI implementation is detected, set the MPI implementation to that one.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>MPI implementation detection only happens during the first call to <a class="el" href="namespaceprodutil_1_1run.html#a63d9ae2ac8b1dde45318d95350b05afb" title="Called by functions inside produtil.run to automatically detect the available MPI implementation...">detect_mpi()</a>. Any later calls will return the cached result from _detected_mpi.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a subclass of <a class="el" href="classprodutil_1_1mpi__impl_1_1mpi__impl__base_1_1ImplementationBase.html" title="Abstract base class for all MPI implementations. ">produtil.mpi_impl.mpi_impl_base.ImplementationBase</a> for generation of <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">produtil.prog.Runner</a> objects from openmp or mpi program specifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>_detected_mpi </dd></dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00221">221</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="run_8py_source.html#l00289">produtil.run.exe()</a>, <a class="el" href="run_8py_source.html#l00183">produtil.run.make_mpi()</a>, <a class="el" href="run_8py_source.html#l00327">produtil.run.make_pipeline()</a>, <a class="el" href="run_8py_source.html#l00307">produtil.run.mpirun()</a>, <a class="el" href="run_8py_source.html#l00473">produtil.run.openmp()</a>, and <a class="el" href="run_8py_source.html#l00428">produtil.run.runsync()</a>.</p>

</div>
</div>
<a id="ac766be0e96246e1b74c556f24aa69d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac766be0e96246e1b74c556f24aa69d7f">&#9670;&nbsp;</a></span>exe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.exe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mpiimpl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">prog.ImmutableRunner</a> object that represents a large serial program that must be run on a compute node. </p>
<dl class="section note"><dt>Note</dt><dd>This function does NOT search $PATH on Cray. That ensures the $PATH will be expanded on the compute node instead. Use <a class="el" href="namespaceprodutil_1_1fileop.html#aa520f12ba7897ddfa1ab2894de7ebd64" title="Searches the $PATH or a specified iterable of directory names to find an executable file with the giv...">produtil.fileop.find_exe()</a> if you want to explicitly search the PATH before execution. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the executable name or path </td></tr>
    <tr><td class="paramname">kwargs</td><td>passed to <a class="el" href="classprodutil_1_1prog_1_1Runner.html#ade5a2e90df814ee4b57b90d3363f538d" title="Creates a new Runner. ">produtil.prog.Runner.__init__</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classprodutil_1_1prog_1_1ImmutableRunner.html" title="An copy-on-write version of Runner. ">produtil.prog.ImmutableRunner</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00289">289</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="run_8py_source.html#l00303">produtil.run.bigexe()</a>, and <a class="el" href="script_8py_source.html#l00204">produtil.testing.script.ProdutilRunner.mpirunner()</a>.</p>

</div>
</div>
<a id="a01495efdbad7b416f438ff6526ebedfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01495efdbad7b416f438ff6526ebedfb">&#9670;&nbsp;</a></span>make_mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.make_mpi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mpi_name</em> = <code><a class="el" href="namespaceprodutil_1_1mpi__impl.html#a4a1c8d01aecee73c028159c41b193c2d">produtil.mpi_impl.NO_NAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an MPI implementation object for the specified MPI implementation. </p>
<p>Creates an object suitable for passing to the mpiimpl argument of various functions in <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a>. The object will implement the requested MPI implementation. This object is NOT used to initialize the <a class="el" href="namespaceprodutil_1_1run.html" title="A shell-like syntax for running serial, MPI and OpenMP programs. ">produtil.run</a>; instead it is simply returned.</p>
<dl class="section return"><dt>Returns</dt><dd>an MPI implementation object for the specified arguments</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_name</td><td>the name of the MPI implementation. If mpi_name=None, an mpiimpl for pure serial programs is returned. If no mpi_name is given, the local machine's available MPI implementation is detected and returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When mpi_name is unset, the detection of the MPI implementation is redone, even if it had been done before by another call to get_mpi() or <a class="el" href="namespaceprodutil_1_1run.html#a63d9ae2ac8b1dde45318d95350b05afb" title="Called by functions inside produtil.run to automatically detect the available MPI implementation...">detect_mpi()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kwargs</td><td>additional arguments passed to <a class="el" href="namespaceprodutil_1_1mpi__impl.html#a8b6e34e8dc0bb2321408fad882bac673" title="Selects a specified MPI implementation, or automatically detects the currently available one...">produtil.mpi_impl.get_mpi()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>produtil.mpi_impl.impi.Implementation.detect() </dd></dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00183">183</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="script_8py_source.html#l00179">produtil.testing.script.ProdutilRunner.__init__()</a>.</p>

</div>
</div>
<a id="ab3201de880ff4d8d45c2671bfb0c2d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3201de880ff4d8d45c2671bfb0c2d40">&#9670;&nbsp;</a></span>make_pipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.make_pipeline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mpiimpl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This internal implementation function generates a prog.PopenCommand object for the specified input, which may be a <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">prog.Runner</a> or <a class="el" href="classprodutil_1_1mpiprog_1_1MPIRanksBase.html" title="This is the abstract superclass of all classes that represent one or more MPI ranks, including MPI ranks that are actually serial programs. ">mpiprog.MPIRanksBase</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">produtil.prog.Runner</a> to convert. This is the output of <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>, <a class="el" href="namespaceprodutil_1_1run.html#a464fb6f6962509db1435c250b2b88fd6" title="Alias for exe() for backward compatibility. ">bigexe()</a> or <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">mpirun()</a> </td></tr>
    <tr><td class="paramname">capture</td><td>if True, capture the stdout into a string </td></tr>
    <tr><td class="paramname">kwargs</td><td>additional keyword arguments, same as for <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">mpirun()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00327">327</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="run_8py_source.html#l00434">produtil.run.run()</a>, <a class="el" href="run_8py_source.html#l00359">produtil.run.runbg()</a>, and <a class="el" href="run_8py_source.html#l00494">produtil.run.runstr()</a>.</p>

</div>
</div>
<a id="a188c8f66465f19fc27e77085170a33e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188c8f66465f19fc27e77085170a33e4">&#9670;&nbsp;</a></span>mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.mpi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an MPIRank object that represents the specified MPI executable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the MPI program to run </td></tr>
    <tr><td class="paramname">kwargs</td><td>logger=L for a logging.Logger to log messages </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00525">525</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="script_8py_source.html#l00204">produtil.testing.script.ProdutilRunner.mpirunner()</a>.</p>

</div>
</div>
<a id="ab39d0f0caa4e35b673279f1e8d5166be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39d0f0caa4e35b673279f1e8d5166be">&#9670;&nbsp;</a></span>mpirun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.mpirun </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mpiimpl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an MPI program specification into a runnable shell program suitable for <a class="el" href="namespaceprodutil_1_1run.html#a051fdcf06abe4cd46bd9b528ed78ff55" title="Executes the specified program and attempts to return its exit status. ">run()</a>, <a class="el" href="namespaceprodutil_1_1run.html#adb62b5e57720ae6f0a012ef77a654be5" title="Executes the specified program or pipeline, capturing its stdout and returning that as a string...">runstr()</a> or <a class="el" href="namespaceprodutil_1_1run.html#a4f375f2804bfd933db8c52d3231642e4" title="This is a simple wrapper round run that raises ExitStatusException if the program exit status is non-...">checkrun()</a>. </p>
<p>Options for kwargs:</p><ul>
<li>allranks=True &mdash; to run on all available MPI ranks. This cannot be used if a specific number of ranks (other than 1) was requested in the arg.</li>
<li>logger=L &mdash; a logging.Logger for log messages</li>
<li>Other platform-specific arguments. See <a class="el" href="namespaceprodutil_1_1mpi__impl.html" title="Converts a group of MPI ranks to a runnable command. ">produtil.mpi_impl</a> for details.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the <a class="el" href="classprodutil_1_1mpiprog_1_1MPIRanksBase.html" title="This is the abstract superclass of all classes that represent one or more MPI ranks, including MPI ranks that are actually serial programs. ">mpiprog.MPIRanksBase</a> describing the MPI program to run. This is the output of the <a class="el" href="namespaceprodutil_1_1run.html#a188c8f66465f19fc27e77085170a33e4" title="Returns an MPIRank object that represents the specified MPI executable. ">mpi()</a> or <a class="el" href="namespaceprodutil_1_1run.html#ab25fe1dbe95b271368ca44e34dafa045" title="Generates an mpiprog.MPISerial object that represents an MPI rank that executes a serial (non-MPI) pr...">mpiserial()</a> function. </td></tr>
    <tr><td class="paramname">kwargs</td><td>additional arguments to control output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">prog.Runner</a> object for the specified <a class="el" href="classprodutil_1_1mpiprog_1_1MPIRanksBase.html" title="This is the abstract superclass of all classes that represent one or more MPI ranks, including MPI ranks that are actually serial programs. ">mpiprog.MPIRanksBase</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00307">307</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="script_8py_source.html#l00204">produtil.testing.script.ProdutilRunner.mpirunner()</a>.</p>

</div>
</div>
<a id="ab25fe1dbe95b271368ca44e34dafa045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25fe1dbe95b271368ca44e34dafa045">&#9670;&nbsp;</a></span>mpiserial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.mpiserial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an <a class="el" href="classprodutil_1_1mpiprog_1_1MPISerial.html" title="Represents a single rank of an MPI program that is actually running a serial program. ">mpiprog.MPISerial</a> object that represents an MPI rank that executes a serial (non-MPI) program. </p>
<p>The given value MUST be from <a class="el" href="namespaceprodutil_1_1run.html#a464fb6f6962509db1435c250b2b88fd6" title="Alias for exe() for backward compatibility. ">bigexe()</a> or <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>, NOT from <a class="el" href="namespaceprodutil_1_1run.html#a188c8f66465f19fc27e77085170a33e4" title="Returns an MPIRank object that represents the specified MPI executable. ">mpi()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the MPI program to run </td></tr>
    <tr><td class="paramname">kwargs</td><td>logger=L for a logging.Logger to log messages </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00532">532</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
<a id="a51d7fdc729ba882177296edcd1d3f10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d7fdc729ba882177296edcd1d3f10f">&#9670;&nbsp;</a></span>openmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.openmp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threads</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mpiimpl</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of OpenMP threads for the specified program. </p>
<dl class="section warning"><dt>Warning</dt><dd>Generally, when using MPI with OpenMP, the batch system must be configured correctly to handle this or unexpected errors will result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The "arg" argument must be from mpiserial, mpi, exe or bigexe.</td></tr>
    <tr><td class="paramname">threads</td><td>The optional "threads" argument is an integer number of threads. If it is not specified, the maximum possible number of threads will be used. Note that using threads=None with mpirun(...,allranks=True) will generally not work unless the batch system has already configured the environment correctly for an MPI+OpenMP task with default maximum threads and ranks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see <a class="el" href="namespaceprodutil_1_1run.html#a051fdcf06abe4cd46bd9b528ed78ff55" title="Executes the specified program and attempts to return its exit status. ">run()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00473">473</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="script_8py_source.html#l00204">produtil.testing.script.ProdutilRunner.mpirunner()</a>.</p>

</div>
</div>
<a id="a051fdcf06abe4cd46bd9b528ed78ff55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051fdcf06abe4cd46bd9b528ed78ff55">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.run </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sleeptime</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the specified program and attempts to return its exit status. </p>
<p>In the case of a pipeline, the highest exit status seen is returned. For MPI programs, exit statuses are unreliable and generally implementation-dependent, but it is usually safe to assume that a program that runs MPI_Finalize() and exits normally will return 0, and anything that runs MPI_Abort(MPI_COMM_WORLD) will return non-zero. Programs that exit due to a signal will return statuses &gt;255 and can be interpreted with WTERMSIG, WIFSIGNALLED, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">produtil.prog.Runner</a> to execute (output of <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>, <a class="el" href="namespaceprodutil_1_1run.html#a464fb6f6962509db1435c250b2b88fd6" title="Alias for exe() for backward compatibility. ">bigexe()</a> or <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">mpirun()</a> </td></tr>
    <tr><td class="paramname">logger</td><td>a logging.Logger to log messages </td></tr>
    <tr><td class="paramname">sleeptime</td><td>time to sleep between checks of child process </td></tr>
    <tr><td class="paramname">kwargs</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00434">434</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="run_8py_source.html#l00456">produtil.run.checkrun()</a>, and <a class="el" href="parsetree_8py_source.html#l02132">produtil.testing.parsetree.EmbedBash.run()</a>.</p>

</div>
</div>
<a id="a496dc065fbd02b7c1b2ff52d76934969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496dc065fbd02b7c1b2ff52d76934969">&#9670;&nbsp;</a></span>runbg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.runbg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capture</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented: background execution. </p>
<p>Runs the specified process in the background. Specify capture=True to capture the command's output. Returns a produtil.prog.PopenCommand. Call poll() to determine process completion, and use the stdout_data property to get the output after completion, if capture=True was specified.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd><a class="el" href="namespaceprodutil_1_1run.html#a496dc065fbd02b7c1b2ff52d76934969" title="Not implemented: background execution. ">produtil.run.runbg()</a> is not implemented</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this is not implemented</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the <a class="el" href="classprodutil_1_1prog_1_1Runner.html" title="Represents a single stage of a pipeline to execute. ">produtil.prog.Runner</a> to execute (output of <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>, <a class="el" href="namespaceprodutil_1_1run.html#a464fb6f6962509db1435c250b2b88fd6" title="Alias for exe() for backward compatibility. ">bigexe()</a> or <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">mpirun()</a> </td></tr>
    <tr><td class="paramname">capture</td><td>if True, capture output </td></tr>
    <tr><td class="paramname">kwargs</td><td>same as for <a class="el" href="namespaceprodutil_1_1run.html#ab39d0f0caa4e35b673279f1e8d5166be" title="Converts an MPI program specification into a runnable shell program suitable for run(), runstr() or checkrun(). ">mpirun()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00359">359</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
<a id="adb62b5e57720ae6f0a012ef77a654be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb62b5e57720ae6f0a012ef77a654be5">&#9670;&nbsp;</a></span>runstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.runstr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the specified program or pipeline, capturing its stdout and returning that as a string. </p>
<p>If the exit status is non-zero, then NonZeroExit is thrown.</p>
<p>Example: </p><div class="fragment"><div class="line">runstr(exe(<span class="stringliteral">&#39;false&#39;</span>),ret=(1))</div></div><!-- fragment --><p>succeeds if "false" returns 1, and raises ExitStatusError otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The "arg" argument must be from mpiserial, mpi, exe or bigexe. </td></tr>
    <tr><td class="paramname">logger</td><td>a logging.Logger for logging messages </td></tr>
    <tr><td class="paramname">kwargs</td><td>You can specify an optional list or tuple "ret" that contains an alternative list of valid return codes. All return codes are zero or positive: negative values represent signal-terminated programs (ie.: SIGTERM produces -15, SIGKILL produces -9, etc.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00494">494</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
<a id="af272da55d241830e5451e122da395b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af272da55d241830e5451e122da395b8f">&#9670;&nbsp;</a></span>runsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.runsync </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mpiimpl</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the "sync" command as an <a class="el" href="namespaceprodutil_1_1run.html#ac766be0e96246e1b74c556f24aa69d7f" title="Returns a prog.ImmutableRunner object that represents a large serial program that must be run on a co...">exe()</a>. </p>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00428">428</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
<a id="a87458edd4ccb66771bf9d503096a28f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87458edd4ccb66771bf9d503096a28f9">&#9670;&nbsp;</a></span>waitprocs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def produtil.run.waitprocs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usleep</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented: background process monitoring. </p>
<p>Waits for one or more backgrounded processes to complete. Logs to the specified logger while doing so. If a timeout is specified, returns False after the given time if some processes have not returned. The usleep argument is the number of microseconds to sleep between checks (can be a fraction). The first argument, procs specifies the processes to check. It must be a produtil.prog.Pipeline (return value from runbg) or an iterable (list or tuple) of such.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd><a class="el" href="namespaceprodutil_1_1run.html#a87458edd4ccb66771bf9d503096a28f9" title="Not implemented: background process monitoring. ">produtil.run.waitprocs()</a> is untested</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is not tested and probably does not work.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procs</td><td>the processes to watch </td></tr>
    <tr><td class="paramname">logger</td><td>the logging.Logger for log messages </td></tr>
    <tr><td class="paramname">timeout</td><td>how long to wait before giving up </td></tr>
    <tr><td class="paramname">usleep</td><td>sleep time between checks </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8py_source.html#l00380">380</a> of file <a class="el" href="run_8py_source.html">run.py</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
